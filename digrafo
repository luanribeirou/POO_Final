public abstract class Digrafo implements Digraph<E,T>{
stactic final class Entry{
  boolean known = false;
  int distancia = Integer.MAX_VALUE;
  int predecessor = Integer.MAX_VALUE;
}
protected int numerodeVertices;
protected int numerodeEdges;
protected Vertex [] vertex;
  
 public void topologicalOrderTraversal(Visitor visitor){
 int[]inDegree = new int[numerodeVertices];
 for(v = 0; v< numerodeVertices; v++)
   inDegree [v] = 0;
  Enumeration p = getEdges ();
   while(p.hasMoreElements()){
 Edge edge = (Edge) p.nextElement();
     Vertex to = edge.getV1();
     inDegree++[to.getNumber];
   }
 Queue queue = new QueueAsLinkedList();
   for(int v = 0; v< numerodeVertices; v++)
     if(inDegree [v] == 0)
       queue.enqueue(vertex[v]);
   while(!queue.isEmpty() && !visitor.isDone()){
     Vertex to = (Vertex) q.nextElement();
     if(inDegree--[to.getNumero()]== 0)
     queue.enqueue(to);
   }
 }
public boolean isStronglyConnected(){
  protected int numerodeVertices;
  protected int numerodeEdges;
  protected Vertex vertex;
  final Counter counte = new Counter();
  for(int v = 0; v<numerodeVertices;v++){
    counter.value = 0;
    PrePostVisitor visitor = new AbstractPrePostVisitor(){
      public void visit(Object object){
        counter.value++;
      }
    };
    depthFirstTraversal(visitor, v);
    if(counter.value != numerodeVertices)
      return false;
  }
  return true;
}
  
 public static Digraph DijkstaAlgorithm(Digraph g, int s){
  int n = g.getNumerodeVertices();
  Entry [] table = new Entry[n];
  for(int v= 0; v < n; v++)
    table [v] = new Entry ();
   table [s].distancia = 0;
   PriorityQueue = new BinaryHeap(new Int (0), g.getVertex(s));
   while(!queue.isEmpty()){
     Association assoc = (Association) queue.dequeueMin();
     Vertex v0 = (Vertex) assoc.getValor();
     int n0 = v0.getnumero();
     if(!table[n0].knowm){
      table [n0].knwom = true;
       Enumeration p = v0.getEmanatingEdges();
       while(p.hasMoreElements()){
         Edge edge = (Edge)p.nextElement();
         Vertex v1 = edge.getMate(v0);
         int n1 = v1.getnumero();
         int wt = (int) edge.getWeight();
         int d = table[n0].distancia + wt.intValue();
         if(table [n1].distancia > d){
           table[n1].distancia = d;
           table[n1].predecessor = n0;
           queue.enqueue(new Association(new Int(d), v1));
         }
       }
     }
   }
   Digraph result = new DigraphAsLists (n);
   for(int v = 0; v < n; v++)
     result.addVertex(v,new Int(table[v].distancia));
   for(v = 0; v < n; v++)
     if(v!= s)
       result.addEdge(v,table[v].predecessor);
   return result;
 }
  
public static Digraph FloydsAlgorith(Digraph g ){
  int n = g.getNumerodeVertices();
  int[][] distancia = new int [n][n];
  for(v = 0; v < n; v++)
  for(int w = 0; w < n; w++)
    distance [v][w] = Integer.MAX_VALUE;
  Enumeration p=g.getEdges();
  while(p.hasMoreElements()){
    Edge edge = (Edge) p.nextElement();
    int wt = (Int) edge.getWeight();
    distancia[edge.getV0().getnumero]
      [edge.getV1().getnumero]= wt.intValor();
  }
  for(int i = 0; i < n; i++)
  for(int v = 0; v < n; v++)
    for(int w = 0; w < n; w++)
      if(distancia[v][i] != Integer.MAX_VALUE && distancia[i][w] != Integer.MAX_VALUE){
        int d = distancia[v][i]+distancia[i][w];
        if(distancia[v][w] > d)
          distancia [v][w] = d;
      }
  Digraph result = new DigraphAsMatrix(n);
  for(int v = 0; v < n; v++)
    result.addVertex (v);
  for(int v = 0; v < n; v++)
  for(int w = 0; w < n; w++)
    if(distancia[v][w] != Integer.MAX_VALUE)
      result.addEdge(v,w,new Int(distancia[v][w]));
  return result;
} 
}
